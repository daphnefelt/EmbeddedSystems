/* ---------------------------------------------------------------------------------
 * Daphne Felt
 * ECEN 5613 - Fall 2025 - Prof. McClure
 * University of Colorado Boulder
 * Edited 10/22/19
 *  --------------------------------------------------------------------------------
 * LAB 3 Pt 3, STM32F4 Discovery Board
 * Testing UART command interface to control PWM duty cycle and frequency
 *  ---------------------------------------------------------------------------------
*/

#include "main.h"
#include "stdio.h"
#include "string.h"

UART_HandleTypeDef huart2;

// func prototypes
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_USART2_UART_Init(void);

#define UART_BUFFER_SIZE 6400

// ansi color codes
#define ANSI_RESET          "\x1b[0m"
#define ANSI_BOLD           "\x1b[1m"
#define ANSI_GREEN_BOLD     "\x1b[1;32m"

// globals
// volatile uint8_t rxData = 0;
// volatile uint8_t rxFlag = 0;
volatile uint8_t dutyCycle = 40;  // default 40%
volatile uint8_t buttonPressed = 0;
volatile uint8_t buttonDirection = 1;  // 1 = increasing, 0 = decreasing
volatile uint16_t pwmFrequency = 10000;  // 10 kHz in Hz


// for the circular buffer for uart
typedef struct {
    uint8_t buffer[UART_BUFFER_SIZE];
    uint16_t head;
    uint16_t tail;
    uint16_t count;
} CircularBuffer;

volatile CircularBuffer rxBuffer = {0};
volatile CircularBuffer txBuffer = {0};

// Helper functions
void bufferPush(volatile CircularBuffer *buf, uint8_t data) {
    if (buf->count < UART_BUFFER_SIZE) {
        buf->buffer[buf->head] = data;
        buf->head = (buf->head + 1) % UART_BUFFER_SIZE;
        buf->count++;
    }
}

uint8_t bufferPop(volatile CircularBuffer *buf) {
    uint8_t data = 0;
    if (buf->count > 0) {
        data = buf->buffer[buf->tail];
        buf->tail = (buf->tail + 1) % UART_BUFFER_SIZE;
        buf->count--;
    }
    return data;
}

uint16_t bufferCount(volatile CircularBuffer *buf) {
    return buf->count;
}

// equiv of putchar
void sendChar(uint8_t ch) {
    bufferPush(&txBuffer, ch);
    // Enable TX interrupt to drain buffer
    USART2->CR1 |= USART_CR1_TXEIE;
}

void sendCharGreen(uint8_t ch) {
    sendString(ANSI_GREEN_BOLD);
    putchar_polled(ch);
    sendString(ANSI_RESET);
}

// check if RX data available
uint8_t getRxChar(uint8_t *ch) {
    if (bufferCount(&rxBuffer) > 0) {
        *ch = bufferPop(&rxBuffer);
        return 1;  // data available
    }
    return 0;  // no data
}

void sendString(const char *str) {
    while (*str) {
    	putchar_polled(*str++);
    }
}

void sendStringGreen(const char *str) {
    sendString(ANSI_GREEN_BOLD);
    sendString(str);
    sendString(ANSI_RESET);
}

/////////////// ADDING IN BAD RX, TX through polling to compare performance
// Blocking RX - CPU waits until character arrives
int getchar_polled(void) {
    while (!(USART2->SR & USART_SR_RXNE));  // Busy-wait
    return USART2->DR;
}

// Blocking TX - CPU waits until FIFO has space
void putchar_polled(int c) {
    while (!(USART2->SR & USART_SR_TXE));  // Busy-wait
    USART2->DR = c;
}

///// TESTS

/////////////// For testing performance
// Performance measurement structure
typedef struct {
    uint32_t tx_chars;
    uint32_t rx_chars;
    uint32_t cpu_cycles_used;
    uint32_t buffer_overflows;
    uint32_t start_time_ms;
} PerfMetrics;

volatile PerfMetrics interrupt_driven_metrics = {0};

// SysTick ISR counter (1ms ticks)
volatile uint32_t milliseconds = 0;

void SysTick_Handler(void) {
    milliseconds++;
}

// Test: Interrupt-driven throughput
void test_interrupt_driven_throughput(void) {
    uint32_t start = milliseconds;
    uint32_t i = 0;

    sendString("\n\rINTERRUPT-DRIVEN TEST (5s)\n\r");
    sendString("Sending 1000 bytes...\n\r");

    // Send 1000 characters as fast as possible
    for (i = 0; i < 100; i++) {
        sendChar('A' + (i % 26));
        interrupt_driven_metrics.tx_chars++;

        // Check for timeout
        if ((milliseconds - start) > 10000) break;
    }

    uint32_t elapsed = milliseconds - start;
    uint32_t throughput_cps = (interrupt_driven_metrics.tx_chars * 1000) / elapsed;

    // adding small delay
    for (volatile uint32_t i = 0; i < 400000; i++);

    //sendString('\n\r');

    char printBuff[80] = {0};
    sprintf(printBuff, "TX: %u chars in %u ms\n", interrupt_driven_metrics.tx_chars, elapsed);
    sendString(printBuff);
}

void test_polled_throughput(void) {
    uint32_t start = milliseconds;
    uint32_t i = 0;
    uint32_t tx_chars = 0;

    sendString("\n\rPOLLED TEST (5s)\n\r");
    sendString("Sending 1000 bytes...\n\r");

    // Send 1000 characters as fast as possible
    for (i = 0; i < 100; i++) {
        putchar_polled('A' + (i % 26));
        tx_chars++;

        // Check for timeout
        if ((milliseconds - start) > 10000) break;
    }

    uint32_t elapsed = milliseconds - start;
    uint32_t throughput_cps = (tx_chars * 1000) / elapsed;

    // adding small delay
    for (volatile uint32_t i = 0; i < 400000; i++);

    //sendString('\n\r');

    char printBuff[80] = {0};
	sprintf(printBuff, "TX: %u chars in %u ms\n\r", tx_chars, elapsed);
	sendString(printBuff);
}

////// BASE FUNCS

void UpdatePWM(uint8_t duty) {
    if (duty > 100) duty = 100;  // cap at 100%
    if (duty < 0) duty = 0;      // cap at 0%

    uint16_t psc = TIM3->PSC;
    uint16_t arr = TIM3->ARR;
    uint32_t ccr_value = (duty * (arr + 1)) / 100;  // For changing PSC

    TIM3->CCR1 = ccr_value; // actual update
    TIM3->CCR2 = ccr_value; // update second channel as well for the LED
}

void UpdatePWMFrequency(uint16_t frequency) {
    if (frequency < 1000) frequency = 1000;       // min 1kHz. Don't want too low bc run into issues with psc being too high
    if (frequency > 50000) frequency = 50000;   // max 50000

    pwmFrequency = frequency;

    // Recalculate PSC and ARR for new frequency
    uint32_t psc_value = (96000000 / 6 / (frequency * 100)) - 1;
    TIM3->PSC = psc_value;

    // Update duty cycle to reflect new settings
    UpdatePWM(dutyCycle);
}

void ReportDutyCycle(void) {
    char buffer[32];
    sprintf(buffer, "Duty Cycle: %d%%\r\n", dutyCycle);
    sendStringGreen(buffer);
}

void ProcessCommand(uint8_t cmd) {
    switch(cmd) {
        case 'P':
        case 'p':
            sendString("\r\n[Query] ");
            ReportDutyCycle();
            break;

        case 'A':
        case 'a':
            if (dutyCycle <= 95) {
                dutyCycle += 5;
            } else {
                dutyCycle = 100;
            }
            UpdatePWM(dutyCycle);
            sendString("\r\n[Increase] ");
            ReportDutyCycle();
            break;

        case 'B':
        case 'b':
            if (dutyCycle >= 5) {
                dutyCycle -= 5;
            } else {
                dutyCycle = 0;
            }
            UpdatePWM(dutyCycle);
            sendString("\r\n[Decrease] ");
            ReportDutyCycle();
            break;

        case 'D':
        case 'd':
            sendString("\r\nEnter duty cycle (0-100%): ");

            // wait for input
            char dutyBuf[8] = {0};
            {
                uint8_t idx = 0;
                uint8_t ch;
                while (1) {
                    if (getRxChar(&ch)) {
                        if (ch == '\r' || ch == '\n') {
                            sendString("\r\n");
                            break;
                        } else if (idx < 7) {
                            dutyBuf[idx++] = ch;
                            sendChar(ch);  // echo
                        }
                    }
                }
                dutyBuf[idx] = '\0';
                uint8_t newDuty = (uint8_t)atoi(dutyBuf);
                dutyCycle = newDuty;
            }

            UpdatePWM(dutyCycle);
            sendString("Duty: ");
            sprintf(dutyBuf, "%u%%\r\n", dutyCycle);
            sendString(dutyBuf);
            break;

        case 'F':
        case 'f':
            sendString("\r\nEnter frequency (1000-50000 Hz): ");

            // wait for input
            char freqBuf[16] = {0};
            {
                uint8_t idx = 0;
                uint8_t ch;
                while (1) {
                    if (getRxChar(&ch)) {
                        if (ch == '\r' || ch == '\n') {
                            sendString("\r\n");
                            break;
                        } else if (idx < 15) {
                            freqBuf[idx++] = ch;
                            sendChar(ch);  // echo
                        }
                    }
                }
                freqBuf[idx] = '\0';
                uint16_t newFreq = (uint16_t)atoi(freqBuf);
                pwmFrequency = newFreq;
            }

            UpdatePWMFrequency(pwmFrequency);
            sendString("Freq: ");
            sprintf(freqBuf, "%u Hz\r\n", pwmFrequency);
            sendString(freqBuf);
            break;

        case 'T':  // Trigger performance test
        case 't':
            test_interrupt_driven_throughput();
            test_polled_throughput();
            break;
    }
}


////////////INTERRUPTS

// BUTTON
void EXTI0_IRQHandler(void){

	if (EXTI->PR & (1<<0)) {
        // adding small debouncing delay
        for (volatile uint32_t i = 0; i < 400000; i++);
        buttonPressed = 1;
		EXTI->PR |= (1<<0);
	}
}

// UART
void USART2_IRQHandler(void) {
    // RX interrupt
    if (USART2->SR & USART_SR_RXNE) {
        uint8_t data = USART2->DR;
        bufferPush(&rxBuffer, data); // add to my circular buffer
    }

    // TX interrupt (only fires if TXE and TXEIE are both set)
    if ((USART2->SR & USART_SR_TXE) && (USART2->CR1 & USART_CR1_TXEIE)) {
        if (bufferCount(&txBuffer) > 0) {
            USART2->DR = bufferPop(&txBuffer);
        } else {
            // Disable TX interrupt when buffer empty
            USART2->CR1 &= ~USART_CR1_TXEIE;
        }
    }
}

///////////// CONFIGS

void GPIO_Config(void) {
    // enable GPIO clocks
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN | RCC_AHB1ENR_GPIOCEN | RCC_AHB1ENR_GPIODEN;

    // PA0 (Button B1) as input with pull-down
    GPIOA->MODER &= ~GPIO_MODER_MODER0;  // Input mode
    GPIOA->PUPDR &= ~GPIO_PUPDR_PUPDR0;
    GPIOA->PUPDR |= GPIO_PUPDR_PUPDR0_1;  // Pull-down

    // PA2 (UART TX) and PA3 (UART RX) as alternate functions
    GPIOA->MODER &= ~(GPIO_MODER_MODER2 | GPIO_MODER_MODER3);
    GPIOA->MODER |= GPIO_MODER_MODER2_1 | GPIO_MODER_MODER3_1;  // AF mode
    GPIOA->AFR[0] |= (7 << 8) | (7 << 12);  // AF7 for USART2

    // PC6 (TIM3_CH1) for PWM output
    GPIOC->MODER &= ~GPIO_MODER_MODER6;
    GPIOC->MODER |= GPIO_MODER_MODER6_1;  // AF mode
    GPIOC->AFR[0] |= (2 << 24);  // AF2 for TIM3

    // PD13 (TIM3_CH2) for second PWM output
    GPIOD->MODER &= ~GPIO_MODER_MODER13;
    GPIOD->MODER |= GPIO_MODER_MODER13_1;  // AF mode
    GPIOD->AFR[1] |= (2 << 4);  // AF2 for TIM3 (AFR[1] is for pins 8-15)

    // don't know if I need, but set PD12 (Green), PD14 (Red), PD15 (Blue) as outputs
    GPIOD->MODER &= ~(GPIO_MODER_MODER12 | GPIO_MODER_MODER14 | GPIO_MODER_MODER15);
    GPIOD->MODER |= GPIO_MODER_MODER12_0 | GPIO_MODER_MODER14_0 | GPIO_MODER_MODER15_0;
}

void UART_Config(void) {
    // Enable USART2 clock
    RCC->APB1ENR |= RCC_APB1ENR_USART2EN;
    // baud rate 115200 at 84MHz
    USART2->BRR = 0x2D9; // BRR = 84,000,000 / (16 Ã— 115200) = 45.572
    
    // Enable USART, TX, RX, and RXNE interrupt
    USART2->CR1 = USART_CR1_UE | USART_CR1_TE | USART_CR1_RE | USART_CR1_RXNEIE;
    
    // Enable USART2 interrupt in NVIC
    NVIC_EnableIRQ(USART2_IRQn);
    NVIC_SetPriority(USART2_IRQn, 0); // highest priority bc want fast response
}

void TIM_Config(void) {
    // Enable TIM3 clock
    RCC->APB1ENR |= RCC_APB1ENR_TIM3EN;

    // Configure TIM3 for PWM
    TIM3->PSC = 95;      // Prescaler
    TIM3->ARR = 99;     // Auto-reload (period) - using 100 for easy percentage calc

    // Configure CH1 as PWM mode 1
    TIM3->CCMR1 &= ~TIM_CCMR1_OC1M;
    TIM3->CCMR1 |= TIM_CCMR1_OC1M_1 | TIM_CCMR1_OC1M_2;  // PWM mode 1
    TIM3->CCMR1 |= TIM_CCMR1_OC1PE;  // Preload enable

    // Ch2 PWM setup
    TIM3->CCMR1 &= ~TIM_CCMR1_OC2M;
    TIM3->CCMR1 |= TIM_CCMR1_OC2M_1 | TIM_CCMR1_OC2M_2;  // PWM mode 1
    TIM3->CCMR1 |= TIM_CCMR1_OC2PE;  // Preload enable

    TIM3->CCR1 = 40; // Set initial duty cycle (40%)
    TIM3->CCR2 = 40; // Initial duty cycle (40%)

    // Enable CH1 output
    TIM3->CCER |= TIM_CCER_CC1E;
    // Enable CH2 output
    TIM3->CCER |= TIM_CCER_CC2E;

    // Enable timer
    TIM3->CR1 |= TIM_CR1_CEN;
}

void EXTI_Config(void) {
    // Enable SYSCFG clock
    RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;

    // EXTI0 to PA0
    SYSCFG->EXTICR[0] &= ~SYSCFG_EXTICR1_EXTI0;
    SYSCFG->EXTICR[0] |= SYSCFG_EXTICR1_EXTI0_PA;

    // Configure EXTI0 for rising edge trigger
    EXTI->IMR |= EXTI_IMR_MR0;    // Unmask interrupt
    EXTI->RTSR |= EXTI_RTSR_TR0;  // Rising edge trigger
    EXTI->FTSR &= ~EXTI_FTSR_TR0; // Disable falling edge

    // Enable EXTI0 interrupt in NVIC
    NVIC_EnableIRQ(EXTI0_IRQn);
    NVIC_SetPriority(EXTI0_IRQn, 1);
}

int main(void)
{
	HAL_Init();
	SystemClock_Config();
	MX_GPIO_Init();
	MX_USART2_UART_Init();
	GPIO_Config();
	TIM_Config();
	EXTI_Config();

	// Enable USART, TX, RX, and RXNE interrupt
	USART2->CR1 = USART_CR1_UE | USART_CR1_TE | USART_CR1_RE | USART_CR1_RXNEIE;
	// Enable USART2 interrupt in NVIC
	NVIC_EnableIRQ(USART2_IRQn);
	NVIC_SetPriority(USART2_IRQn, 0); // highest priority bc want fast response

	// Configure SysTick for 1ms interrupts (96 MHz clock)
	SysTick->LOAD = 96000 - 1;
	SysTick->VAL = 0;
	SysTick->CTRL = 0x07;  // Enable with system clock

	// Initial message
	sendStringGreen("\r\n---------STM PWM Program-------\r\n");
	sendString("Commands:\r\n");
	sendString("P: Print duty cycle\r\n");
	sendString("A: Increase duty cycle by 5%\r\n");
	sendString("B: Decrease duty cycle by 5%\r\n");
	sendString("F: Change cycle freq\r\n");
	sendString("D: Directly change duty cycle\r\n");
	sendString("T: Test polled vs interrupt driven UART\r\n");
	sendString("Button: Change duty cycle by 10%\r\n");
	sendString("-------------------------------\r\n");

	ReportDutyCycle(); // just first time saying what's up. Starts at 40%

	while (1)
	{
		uint8_t rxDataLocal;
		if (getRxChar(&rxDataLocal)) {
			sendCharGreen(rxDataLocal);  // echo back in green
			ProcessCommand(rxDataLocal);
		}

		if (buttonPressed) {
			buttonPressed = 0;  // clear flag

			if (buttonDirection) {  // increasing
				if (dutyCycle >= 100) {
					sendString("\r\n[Direction Change] Decreasing");
					buttonDirection = 0;
					dutyCycle = 90;  // now going down
				} else {
					dutyCycle += 10;
				}
			} else {  // decreasing
				if (dutyCycle <= 0) {
					sendString("\r\n[Direction Change] Increasing");
					buttonDirection = 1;
					dutyCycle = 10; // now going up
				} else {
					dutyCycle -= 10;
				}
			}
			UpdatePWM(dutyCycle);
			sendString("\r\n[Button Press] ");
			ReportDutyCycle();
		}
	}
}

//////////////////////////////////////////////////////////
////////////////////// BUILT IN SETUP - SYSCLOCK AND UART2
//////////////////////////////////////////////////////////

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief USART2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART2_UART_Init(void)
{

  /* USER CODE BEGIN USART2_Init 0 */

  /* USER CODE END USART2_Init 0 */

  /* USER CODE BEGIN USART2_Init 1 */

  /* USER CODE END USART2_Init 1 */
  huart2.Instance = USART2;
  huart2.Init.BaudRate = 115200;
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart2) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN USART2_Init 2 */

  /* USER CODE END USART2_Init 2 */

}

/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  /* USER CODE BEGIN MX_GPIO_Init_1 */

  /* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOA_CLK_ENABLE();

  /* USER CODE BEGIN MX_GPIO_Init_2 */

  /* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */

/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
